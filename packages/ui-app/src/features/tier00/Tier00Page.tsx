import React from 'react';
import { WizardShell } from '../../components/wizard/index.js';
import { tier00Steps } from './steps.js';
import type { UISchemaField } from '@docs-as-code/form-renderer';
import { Tier00SolutionDesignZ } from '@docs-as-code/shared-types/dist/schemas/index.js';
import { ProjectContext } from '../../state/ProjectContext.js';
import { FileBridgeClient } from '@docs-as-code/file-bridge-client';
import { tier00Paths } from '../../utils/paths.js';
import { ensureSeededEnvironments, pruneToAllowedShape, canonicalizeTier00, emitTier00Yaml, normalizeKeyQuestions, ensurePath, type AllowShape } from './services/index.js';
import { scanToolkitRepo, ensureToolkitRepoInitialized } from '../../services/toolkit/index.js';
//

export function Tier00Page() {
    const ctx = React.useContext(ProjectContext);
    if (!ctx) return null;
    const { settings } = ctx;
    const [formKey, setFormKey] = React.useState(0);
    const [defaults, setDefaults] = React.useState<any>({ schemaVersion: 1, environments: [{ name: 'dev' }, { name: 'prod' }] });
    const client = React.useMemo(() => new FileBridgeClient({ baseUrl: settings.bridgeBaseUrl }), [settings.bridgeBaseUrl]);

    const [/* cdfCliModal */, setCdfCliModal] = React.useState<{ open: boolean; message?: string }>(() => ({ open: false }));

    const steps = React.useMemo(() => tier00Steps, []);

    React.useEffect(() => {
        if (!settings.projectRoot) return;
        const { uiState } = tier00Paths(settings.projectRoot);
        (async () => {
            try {
                const raw = await client.read(uiState);
                if (raw && raw.trim().length > 0) {
                    const json = JSON.parse(raw);
                    const seeded = ensureSeededEnvironments(json);
                    setDefaults(seeded);
                    setFormKey((k) => k + 1);
                }
                // Non-blocking scan to seed from existing Toolkit files
                const scan = await scanToolkitRepo(client);
                if (scan.environments.length || scan.modules.length) {
                    setDefaults((prev: any) => ({
                        ...prev,
                        environments: prev.environments?.length ? prev.environments : scan.environments,
                        modules: scan.modules
                    }));
                }
            } catch {}
        })();
    }, [settings.projectRoot, client]);

    async function ensureRepoInitialized(_root: string) { await ensureToolkitRepoInitialized(client); }

    function collectFromFields(shape: AllowShape, fields: UISchemaField[], basePath?: string) {
        for (const f of fields) {
            const kind = (f as any).kind;
            if (kind === 'group') {
                const path = (f as any).path ? `${basePath ? basePath + '.' : ''}${(f as any).path}` : basePath || '';
                collectFromFields(shape, (f as any).fields, path);
            } else if (kind === 'array') {
                const path = `${basePath ? basePath + '.' : ''}${(f as any).path}`;
                const arrNode = ensurePath(shape, path.split('.'));
                if (!arrNode.__array) arrNode.__array = {} as any;
                collectFromFields(arrNode.__array!, (f as any).item.fields, '');
            } else if (kind) {
                const id = (f as any).id as string;
                if (!id) continue;
                const full = `${basePath ? basePath + '.' : ''}${id}`;
                const parts = full.split('.');
                let cur = shape;
                for (let i = 0; i < parts.length - 1; i++) {
                    const p = parts[i];
                    if (!p) continue;
                    if (!(cur as any)[p]) (cur as any)[p] = {} as any;
                    cur = (cur as any)[p] as AllowShape;
                }
                const leaf = parts[parts.length - 1];
                if (leaf) (cur as any)[leaf] = true;
            }
        }
    }

    function buildAllowedShapeFromSteps(): AllowShape {
        const shape: AllowShape = {};
        for (const step of tier00Steps) {
            collectFromFields(shape, step.uiSchema.fields as any);
        }
        // Add fields generated by the app but not directly edited
        // - Use case ids
        const bc = ensurePath(shape, ['businessContext']);
        const uca = (bc.useCases as AllowShape) || (bc.useCases = {} as AllowShape);
        if (!uca.__array) uca.__array = {} as any;
        (uca.__array as any).id = true;
        // - schemaVersion and repositoryRoot
        (shape as any).schemaVersion = true;
        (shape as any).repositoryRoot = true;
        return shape;
    }

    // Normalize nested objects to match the schema and drop deprecated fields/invalid refs

    async function handleSave(data: any, writeYaml = false) {
        // Normalize Key Questions to a single top-level array with links
        data = normalizeKeyQuestions(data);
        
        // Prune unknown keys based on the UI schema (source-of-truth)
        const allowShape = buildAllowedShapeFromSteps();
        // Merge pruned data with minimal required defaults so fields don't disappear on first save
        const pruned = pruneToAllowedShape(data, allowShape);
        let canonical: any = {
            schemaVersion: 1,
            businessContext: { useCases: [] },
            environments: [],
            ...pruned
        };
        // Validate against schema and coerce partials if needed (keeps only declared fields)
        try {
            const parsed = Tier00SolutionDesignZ.partial().safeParse(canonical);
            if (parsed.success) {
                canonical = parsed.data as any;
            }
        } catch {}

        // Canonicalize lists and ids
        canonical = canonicalizeTier00(canonical);

        // Persist UI state JSON and YAML derivation (optional)
        try {
            const { uiState, yaml: yamlPath } = tier00Paths(settings.projectRoot!);
            const stateToStore = { ...canonical, repositoryRoot: settings.projectRoot };
            await client.write(uiState, JSON.stringify(stateToStore, null, 2));
            if (writeYaml) {
                const yamlText = await emitTier00Yaml(stateToStore);
                await client.write(yamlPath, yamlText);
            }
        } catch (e: any) {
            console.warn('[tier00] Failed to write UI state or YAML:', e?.message || e);
        }
    }

    function collectFromStepsForSave(data: any): any {
        const allowShape = buildAllowedShapeFromSteps();
        const pruned = pruneToAllowedShape(data, allowShape);
        return pruned;
    }

    async function onFinish(data: any) {
        const pruned = collectFromStepsForSave(data);
        await handleSave(pruned, true);
        try {
            await ensureRepoInitialized(settings.projectRoot!);
        } catch (e: any) {
            setCdfCliModal({ open: true, message: String(e?.message || e) });
        }
    }

    return (
        <WizardShell key={formKey} steps={steps as any} initialData={defaults} onChange={() => {}} onSaveStep={handleSave} onFinish={onFinish} phase="phase1" />
    );
}

