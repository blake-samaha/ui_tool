# Requirements Template Schemas

This directory contains JSON Schemas for validating the YAML requirements
templates the UI emits. These are inputs for Graph/CDM-aligned workflows and
downstream Toolkit generation.

- 00 Solution Design Principles → `00_Solution_Design_Principles.schema.json`
- 01 Conceptual Model → `01_Conceptual_Model.schema.json`
- XX Object Specification → `XX_Object_Specification.schema.json`

## Purpose: YAML vs JSON files

- YAML (`*.template.yaml`)
  - Canonical examples of the requirements templates the UI will emit.
  - Serve as reference for exact keys, nesting, and ordering.
  - Are the inputs collected from users (or generated by the UI) and saved
    under `project_templates/**`.
  - Not CDF Toolkit YAML; they are requirements used to generate Toolkit
    YAML, RAW definitions, and transformations downstream.

- JSON (`*.schema.json`)
  - JSON Schemas that define the allowed structure, types, and constraints
    of the YAML templates.
  - Used by the UI to validate forms and exported YAML (round-trip safety).
  - Can be used to generate Zod/TypeScript types for compile-time safety.
  - Not user-edited; they are developer-owned specifications.

## How they work together

1. The UI renders forms driven by these JSON Schemas.
2. On export, the UI emits YAML matching the schemas, using the examples as
   canonical shape and ordering.
3. Downstream automation or AI maps the requirements YAML to Toolkit YAML and
   other artifacts for deployment.

Notes
- All templates include `schemaVersion` for future migrations.
- Identifiers prefer snake_case for module IDs and camelCase for object IDs.
- The schemas avoid classical assets; use DM spaces, views, and typed edges.
- Environment fields use snake_case (e.g., `cdf_cluster`, `cdf_region`,
  `idp_tenant_id`, `admin_group_source_id`, `user_group_source_id`) to match
  the requirements document and downstream usage.
 - Prefer Core Data Model alignment (Graph-first): use `implementsCore` to declare adoption
   of `cdf_cdm` views like `CogniteAsset`, `CogniteEvent`, `CogniteFile`,
   `CogniteTimeSeries`, `CogniteSequence`. For Process Industry Models, use
   `externalReferences[].space` and `implements` lists.
 - We do not require a classical category enum (Asset/Event/File/etc.) in
   conceptual objects; Graph semantics come from which views you implement and
   the typed edges you define.

